#define NOLOG4NET
#define WriteEnable
#if PROTECTED
using System;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;
using Guardant;

#if !NOLOG4NET 
using log4net;
#endif


namespace GRD
{
    
    /// <summary>
    /// Thread-safe singleton example created at first call
    /// </summary>
    public sealed class GRDEndUser
    {



#if !NOLOG4NET 
        static readonly ILog log = LogManager.GetLogger(typeof(GRD));
#endif

        public static readonly GRDEndUser Instance = new GRDEndUser();

        private Handle _grdHandle = new Handle(); // Creates empty handle for Guardant protected container

//        private string _keyId;

        private int _farmCntCache;

        private int _cacheTicks;

        private byte _modelid;
        private ushort _type;
        private ushort _lanRes;
        private uint _id;

        /// <summary>
        /// Private constructor prevents instantiation from other classes
        /// </summary>
        private GRDEndUser()
        {
            try
            {
                //Connect();
            }
            catch (Exception e)
            {
//                if (e.InnerException is System.DllNotFoundException)
//                {
                MessageBox.Show(e.InnerException.Message, "Фатальная ошибка!", MessageBoxButtons.OK, MessageBoxIcon.Error);
                logIt(e.InnerException.Message);
                Environment.Exit(100);
//                }
            }
        }

        ~GRDEndUser()
        {
            Disconnect();
        }

        private static void logIt(string txt)
        {
#if !NOLOG4NET
            log.Debug(txt);
#else
            System.Diagnostics.Debug.WriteLine(txt);
            TextWriter logFile;

            logFile = new StreamWriter(".\\log.txt",true);

            logFile.WriteLine(txt);

            logFile.Close();

#endif
        }

        public string GetKeyID()
        {
            return "";
//            return _keyId;
        }

        public int GetFarmsCnt()
        {
            uint farms = 0;
            int farmCnt = -1;
            const uint addr = 1314;

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";

            logStr = "Reading Farm cnt : ";
            retCode = GrdApi.GrdRead(_grdHandle, addr, out farms);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                logStr += string.Format("; CNT = {0:D}", farms);
                farmCnt = (int) farms;
            }
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            _farmCntCache = farmCnt;
            _cacheTicks = Environment.TickCount & Int32.MaxValue;

            return farmCnt;
        }

        public int GetFarmsCntCache()
        {
            if ((Environment.TickCount & Int32.MaxValue) > _cacheTicks + 60*1000)
            {
                GetFarmsCnt();
            }

            return _farmCntCache;
        }

        public string GetOrgName()
        {
            string nm = "";
            const uint addr = 1214;

            byte[] bts = new byte[100];

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";

            logStr = "Reading Organization Name : ";
            retCode = GrdApi.GrdRead(_grdHandle, addr, 100, out bts);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                nm = Cp1251BytesToString(bts, 0, 100);
                logStr += "; Name = " + nm;
            }
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            return nm;
        }

        public bool ValidKey()
        {
/*            byte[] bts = new byte[32];
            uint addr;
            addr = 1182;
            string marker = "";

            bool valid;

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";

            logStr = "Reading Marker : ";
            retCode = GrdApi.GrdRead(_grdHandle, addr, 16, out bts);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                marker = AsciiBytesToString(bts, 0, 32);
                logStr += "; \"" + marker + "\"";
            }
            if (marker != "9-bits RabSoft")
            {
                logStr += "; No correct marker";
                logIt(logStr);
                ErrorHandling(_grdHandle, GrdE.VerifyError);
                valid = false;
            }
            else
            {
                logStr += "; Correct marker";
                logIt(logStr);
                ErrorHandling(_grdHandle, retCode);
                valid = true;
            }
            return valid;
 */
            return true;
        }

        private uint GetFlags(uint byteNum)
        {
            const uint addr = 1318;

            byte[] bts = new byte[8];

            uint res = 0;

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";

            logStr = "Reading Role Flags : ";
            retCode = GrdApi.GrdRead(_grdHandle, addr, 8, out bts);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                UInt64 flgs = BitConverter.ToUInt64(bts, 0);
                logStr += string.Format("; Full Flags = {0:D}", flgs);
                logStr += string.Format("; Flags = {3} - {2} - {1} - {0}", Convert.ToString(bts[0], 2), Convert.ToString(bts[1], 2), Convert.ToString(bts[2], 2), Convert.ToString(bts[3], 2));
                res = bts[byteNum];
            }
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            return res;
        }

        public bool GetFlagZootech()
        {
            return ((GetFlags(0) & Convert.ToByte("00000001", 2)) > 0);
        }

        public bool GetFlagGenetics()
        {
            return ((GetFlags(0) & Convert.ToByte("00000010", 2)) > 0);
        }

        /// <summary>
        /// Резервные копии
        /// </summary>
        /// <returns></returns>
        public bool GetFlagServer()
        {
            return ((GetFlags(0) & Convert.ToByte("00000100", 2)) > 0);
        }

        /// <summary>
        /// Стерильный цех
        /// </summary>
        /// <returns></returns>
        public bool GetFlagButcher()
        {
            return ((GetFlags(0) & Convert.ToByte("00001000", 2)) > 0);
        }

        public DateTime GetDateStart()
        {
            const uint addr = 1326;

            DateTime dt = new DateTime();

            byte[] bts = new byte[12];

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";

            logStr = "Reading Start Date : ";
            retCode = GrdApi.GrdRead(_grdHandle, addr, 12, out bts);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                string nm = Cp1251BytesToString(bts, 0, 12);

                DateTimeFormatInfo dtfi = new CultureInfo("en-US", false).DateTimeFormat;

                dt = Convert.ToDateTime(nm, dtfi);
                logStr += "; Date = " + dt.ToString();
            }
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            return dt;
        }


        public DateTime GetDateEnd()
        {
            const uint addr = 1338;

            DateTime dt = new DateTime();

            byte[] bts = new byte[12];

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";

            logStr = "Reading End Date : ";
            retCode = GrdApi.GrdRead(_grdHandle, addr, 12, out bts);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                string nm = Cp1251BytesToString(bts, 0, 12);

                DateTimeFormatInfo dtfi = new CultureInfo("en-US", false).DateTimeFormat;

                dt = Convert.ToDateTime(nm, dtfi);
                logStr += "; Date = " + dt.ToString();
            }
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            return dt;
        }

        public GrdE ReConnect()
        {
            GrdE retCode;
            retCode=Disconnect();
            if (retCode == GrdE.OK)
            {
                return Connect();
            } else
            {
                return retCode;
            }
        }

        const uint cryptPu = 0x8568683U;
        const uint cryptRd = 0x56547675U;

        const uint PublicCode = 0x9BD54F75 - cryptPu; // Must be encoded             
        const uint ReadCode = 0xFE8392B2 - cryptRd; // Must be encoded             

        private GrdE Connect()
        {
            GrdE retCode; // Error code for all Guardant API functions
            //string KeyId = "";


            // Variables to use in GrdSetFindMode()
            GrdFMR remoteMode; // Operation mode flags                    
            GrdFM dongleFlags; // Operation mode flags                    
            uint programNumber = 0; // Program number                          
            uint version = 0; // Version                                 
            uint dongleID = 0; // Dongle ID
            uint modelID = 0; // Dongle model
            //byte[] typeID = new byte[2];// Dogle type
            uint serialNumber; // Serial number                           
            uint bitMask; // Bit mask                                
            GrdDT dongleType; // Dongle type                             
            GrdFMM dongleModel; // Dongle model                             
            GrdFMI dongleInterface; // Dongle interface                             

            FindInfo findInfo; //= new FindInfo();   // structure used in GrdFind()

//            UInt32 tempData; // Temporary data         

//            uint lms;

            string logStr = "";

            // Initialize this copy of GrdAPI. GrdStartup() must be called once before first GrdAPI call at application startup
            //            logIt("Initialize this copy of GrdAPI :");
            logStr = "Initialize this copy of GrdAPI : ";
            retCode = GrdApi.GrdStartup(GrdFMR.Local); // + GrdFMR.Remote if you want to use network dongles
            //Console.WriteLine("Address of hGrd: " + hGrd.Address);
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);
            if (retCode != GrdE.OK)
            {
                return retCode;
            }

            // -----------------------------------------------------------------
            // Creating Grd protected container & returning it's handle
            // -----------------------------------------------------------------
            logStr = "Create Guardant protected container : ";
            _grdHandle = GrdApi.GrdCreateHandle(_grdHandle, GrdCHM.MultiThread);
            if (_grdHandle.Address == 0) // Some error found?
            {
                logStr += GrdApi.PrintResult((int) retCode);
                logIt(logStr);
                return ErrorHandling(new Handle(0), GrdE.MemoryAllocation);
            }
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, GrdE.OK); // Print success information
            if (retCode != GrdE.OK)
            {
                return retCode;
            }

            // -----------------------------------------------------------------
            // Store dongle codes in Guardant protected container
            // -----------------------------------------------------------------
            logStr = "Storing dongle codes in Guardant protected container : ";
            retCode = GrdApi.GrdSetAccessCodes(_grdHandle, // Handle to Guardant protected container
                                               PublicCode + cryptPu, // Public code, should always be specified
                                               ReadCode + cryptRd // Private read code; you can omit this code and all following via using of overloaded function;
                                               );
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);
            if (retCode != GrdE.OK)
            {
                return retCode;
            }

            // -----------------------------------------------------------------
            // Set dongle search criteria
            // -----------------------------------------------------------------
            logStr = "Setting dongle search conditions : ";
            remoteMode = GrdFMR.Local; // Local dongles only
            dongleFlags = GrdFM.Type; // Check by bProg, bVer & dongle type flag
//            dongleFlags = GrdFM.NProg | GrdFM.Ver | GrdFM.Type; // Check by bProg, bVer & dongle type flag
            //            programNumber = 1; // Check by specified program number                
            programNumber = 0; // Check by specified program number                
            dongleID = 0; // This search mode is not used                     
            serialNumber = 0; // This search mode is not used                     
//            version = 1; // Check by specified version                       
            version = 0; // Check by specified version                       
            bitMask = 0; // This search mode is not used                     
//            dongleType = GrdDT.GSII64; // Dongle that supports GSII64 algorithm   
            dongleType = GrdDT.TRU; // Dongle that supports GSII64 algorithm   
            dongleModel = GrdFMM.ALL; // Guardant Stealth III dongle
            dongleInterface = GrdFMI.ALL; // of any interface

            // All following GrdFind() & GrdLogin() calls before next
            // GrdSetFindMode() will use specified flag values. 
            // If dongle field values and specified values do not match, error code is
            // returned. Both access code and flags are required to call the dongle.
            retCode = GrdApi.GrdSetFindMode(_grdHandle,
                                            remoteMode,
                                            dongleFlags,
                                            programNumber,
                                            dongleID,
                                            serialNumber,
                                            version,
                                            bitMask,
                                            dongleType,
                                            dongleModel,
                                            dongleInterface);
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);
            if (retCode != GrdE.OK)
            {
                return retCode;
            }

            // -----------------------------------------------------------------
            // Search for all specified dongles and print ID's
            // -----------------------------------------------------------------
            logStr = "Searching for all specified dongles and print info about it's : ";
            retCode = GrdApi.GrdFind(_grdHandle, GrdF.First, out dongleID, out findInfo);
            if (retCode == GrdE.OK) // Print table header if at least one dongle found
            {
                logStr += "; Found dongle with following ID : ";
            }
            while (retCode == GrdE.OK)
            {
                // Print info about dongles found
                logStr += string.Format(" {0,8:X}", dongleID); // Dongle's ID (unique)
                logStr += " type:"+findInfo.wType.ToString();
                _type = findInfo.wType;
                _lanRes = findInfo.wRealNetRes;
                // Find next dongle
                retCode = GrdApi.GrdFind(_grdHandle, GrdF.Next, out dongleID, out findInfo);
            }
            logIt(logStr);
            if (retCode == GrdE.AllDonglesFound) // Search has been completed?
            {
                logIt("Dongles search is complete with no errors");
            }
            else
            {
                ErrorHandling(_grdHandle, retCode);
                if (retCode != GrdE.OK)
                {
                    return retCode;
                }
            }

            // -----------------------------------------------------------------
            // Search for the specified local or remote dongle and log in
            // -----------------------------------------------------------------
            logStr = "Searching for the specified local or remote dongle and log in : ";
            // If command line parameter is specified, License Management System functions are used
            //lms = -1;
            // All following Guardant API calls before next GrdCloseHandle()/GrdLogin() will use this dongle
//            retCode = GrdApi.GrdLogin(_grdHandle, lms, GrdLM.PerStation);
            retCode = GrdApi.GrdLogin(_grdHandle, GrdLM.PerStation);
            logStr += GrdApi.PrintResult((int)retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);
            if (retCode != GrdE.OK)
            {
                return retCode;
            }

            // -----------------------------------------------------------------
            // Obtain model value of the dongle via hGrd handle
            // -----------------------------------------------------------------
            logStr = "Obtaining model value of the dongle via hGrd handle : ";
            retCode = GrdApi.GrdGetInfo(_grdHandle, GrdGIL.Model, out modelID);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                logStr += string.Format("; ModelID = {0:X}", modelID);
                if (modelID == (uint) GrdDM.GS3SU)
                {
                    logStr += "; We got right model";
                }
                _modelid = (byte)modelID;
            }
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);
            if (retCode != GrdE.OK)
            {
                return retCode;
            }
            
            logStr = "Obtaining dongle id via hGrd handle : ";
            retCode = GrdApi.GrdGetInfo(_grdHandle, GrdGIL.ID, out modelID);
            logStr += GrdApi.PrintResult((int)retCode);
            if (retCode == GrdE.OK)
            {
                logStr += string.Format("; ID = {0:X}", modelID);
                _id = modelID;
            }
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);
            if (retCode != GrdE.OK)
            {
                return retCode;
            }
            /*
                        // -----------------------------------------------------------------
                        // Set System Address Mode (SAM) as default mode
                        // -----------------------------------------------------------------
                        logStr = "Setting System Address Mode as default mode : ";
                        retCode = GrdApi.GrdSetWorkMode(_grdHandle, GrdWM.SAM, GrdWMFM.DriverAuto);
                        logStr += GrdApi.PrintResult((int) retCode);
                        logIt(logStr);
                        ErrorHandling(_grdHandle, retCode);
                        if (retCode != GrdE.OK)
                        {
                            return retCode;
                        }

                        // -----------------------------------------------------------------
                        // Read ID field value from the dongle. 
                        // -----------------------------------------------------------------           
                        logStr = "Reading ID field value : ";
                        retCode = GrdApi.GrdRead(_grdHandle, GrdSAM.dwID, out tempData);
                        logStr += GrdApi.PrintResult((int) retCode);
                        if (retCode == GrdE.OK)
                        {
                            logStr += string.Format("; ID = {0:X}", tempData);
                            _keyId = string.Format("{0:X}", tempData);
                        }
                        logIt(logStr);
                        ErrorHandling(_grdHandle, retCode);
                        if (retCode != GrdE.OK)
                        {
                            return retCode;
                        }
                        */
/*            logStr = "Setting User Address Mode as default mode : ";
            retCode = GrdApi.GrdSetWorkMode(_grdHandle, GrdWM.UAM, GrdWMFM.DriverAuto);
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);
            if (retCode != GrdE.OK)
            {
                return retCode;
            }
*/
/*
            byte[] bts = new byte[32];
            uint addr;
            addr = 1182;
            string marker = "";

            logStr = "Reading Marker : ";
            retCode = GrdApi.GrdRead(_grdHandle, addr, 16, out bts);
            logStr += GrdApi.PrintResult((int) retCode);
            if (retCode == GrdE.OK)
            {
                marker = AsciiBytesToString(bts, 0, 32);
                logStr += "; \"" + marker + "\"";
            }
            if (marker != "9-bits RabSoft")
            {
                logStr += "; No correct marker";
                logIt(logStr);
                ErrorHandling(_grdHandle, GrdE.VerifyError);
                return GrdE.VerifyError;
            }
            else
            {
                logStr += "; Correct marker";
                logIt(logStr);
                ErrorHandling(_grdHandle, retCode);
            }

            */
            return GrdE.OK;
        }

        public void write_test()
        {
            const uint addr = 1214;
            string dt = "Testing data22";
            WriteToKey(dt,addr, 100);
        }



        public void get_question()
        {
            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "Generate encrypted question and initialize remote update procedure: ";
            byte[] abyQuestion = new byte[8];
            ulong dongleTime = 0;
            byte[] deadTimes = new byte[128];
            uint id;
            uint pub;
            uint deadTimesNumber = 0;
            byte[] hash = new byte[8];



            if (((GrdDT)_type & GrdDT.RTC) == GrdDT.RTC) // End User dongle supports RTC 
            {
                retCode = GrdApi.GrdTRU_GenerateQuestionTime(
                                                            _grdHandle,// handle to Guardant protected container 
                                                            out abyQuestion,//	pointer to question					8 bytes (64 bit) 
                                                            out id,// pointer to dongle ID					4 bytes 
                                                            out pub,// pointer to dongle Public Code			4 bytes 
                                                            out dongleTime,// pointer to dongle time (encrypted)	8 bytes 
                                                            128 * sizeof(byte),// size of DeadTimes array in bytes 
                                                            out deadTimes,//			pointer to array of DeadTimes 
                                                            out deadTimesNumber,//		{ number of returned DeadTimes }
                                                            out hash//				{ pointer to Hash of previous data		8 bytes }
                                                            );

            }
            else
            {
                retCode = GrdApi.GrdTRU_GenerateQuestion(
                                                            _grdHandle,// handle to Guardant protected container 
                                                            out abyQuestion,//	pointer to question					8 bytes (64 bit) 
                                                            out id,// pointer to dongle ID					4 bytes 
                                                            out pub,// pointer to dongle Public Code			4 bytes 
                                                            out hash//				{ pointer to Hash of previous data		8 bytes }
                                                            );
            }
            logStr += GrdApi.PrintResult((int)retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            FileStream wFile;

            wFile = new FileStream(".\\question.bin", FileMode.Create);
            byte[] buf;

            buf = BitConverter.GetBytes(_type);
            wFile.Write(buf, 0, buf.Length);
            buf = BitConverter.GetBytes(_lanRes);
            wFile.Write(buf, 0, buf.Length);
            buf = BitConverter.GetBytes(_modelid);
            wFile.Write(buf, 0, buf.Length);

            wFile.Write(abyQuestion, 0, abyQuestion.Length);

            buf = BitConverter.GetBytes(id);
            wFile.Write(buf, 0, buf.Length);

            buf = BitConverter.GetBytes(pub);
            wFile.Write(buf, 0, buf.Length);

            wFile.Write(hash, 0, hash.Length);

            if (((GrdDT)_type & GrdDT.RTC) == GrdDT.RTC) // End User dongle supports RTC 
            {
                buf = BitConverter.GetBytes(dongleTime);
                wFile.Write(buf, 0, buf.Length);

                buf = BitConverter.GetBytes(deadTimesNumber);
                wFile.Write(buf, 0, buf.Length);

                wFile.Write(deadTimes, 0, deadTimes.Length);
            }

            wFile.Close();

        }

        public void set_answer()
        {
            FileStream wFile;

            wFile = new FileStream(".\\answer.bin", FileMode.Open);
            
            byte[] buf;

            buf = new byte[4];

            wFile.Read(buf, 0, 4);

            Int32 asize = BitConverter.ToInt32(buf, 0);

            buf = new byte[asize];

            wFile.Read(buf, 0, asize);

            wFile.Close();

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "Apply encrypted answer data: ";

            retCode = GrdApi.GrdTRU_ApplyAnswer(
                                                _grdHandle, //			{ handle to Guardant protected container of dongle with }
                                                //				{ corresponding pre-generated question }
                                                buf //		{ answer data update buffer prepared and encrypted by GrdTRU_EncryptAnswer }
                                                );

            logStr += GrdApi.PrintResult((int)retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            byte[] Buffer = new byte[16];
            byte[] InitVector = new byte[16];


            logStr = "Testing new mask by GrdTransform test:";
            retCode = GrdApi.GrdTransform(_grdHandle, 0, 8, Buffer, 0, InitVector);
            logStr += GrdApi.PrintResult((int)retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);




        }


        public bool WriteToKey(string txt, uint offset, int length)
        {
            return WriteToKey(Encoding.GetEncoding(1251).GetBytes(txt), offset, length);
        }

        public bool WriteToKey(byte[] buffer, uint offset, int length)
        {
            GrdE retCode; // Error code for all Guardant API functions
            string logStr;
            logStr = "Locking dongle for read/write operations : ";
            retCode = GrdApi.GrdLock(_grdHandle,
                                     10000, // dwTimeoutWaitForUnlock. Max GrdAPI unlock waiting time. -1 == infinity. 0 == no waiting
                                     10000, // dwTimeoutAutoUnlock.    Max dongle locking time in ms.  -1 == infinity. 0 == 10000 ms (10 sec)
                                     GrdLM.Read | GrdLM.Write); // Prevent reading and writing from other threads and tasks (GrdRead() & GrdWrite())
            logStr += GrdApi.PrintResult((int) retCode);

            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            logStr = "Writing data : ";
            retCode = GrdApi.GrdWrite(_grdHandle, offset, length, buffer);
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            logStr = "Unlocking dongle : ";
            retCode = GrdApi.GrdUnlock(_grdHandle);
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            return true;
        }

        public bool ReadBytes(out byte[] buffer, uint offset, int length)
        {
//            buffer = new byte[length];

            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";

            logStr = "Reading Role Flags : ";
            retCode = GrdApi.GrdRead(_grdHandle, offset, length, out buffer);
            logStr += GrdApi.PrintResult((int)retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            return (retCode==GrdE.OK);
        }

        public string ReadString(uint offset, int length)
        {
            byte[] buffer = new byte[length];
            if (ReadBytes(out buffer, offset, length))
            {
                string str = AsciiBytesToString(buffer, 0, (int) length);
                return str;
            }
            else
            {
                return "";
            }
        }

        public uint ReadUInt(uint offset)
        {
            byte[] buffer = new byte[4];
            if (ReadBytes(out buffer, offset, 4))
            {
                return BitConverter.ToUInt32(buffer,0);
            }
            else
            {
                return 0;
            }
        }

        private static string AsciiBytesToString(byte[] buffer, int offset, int maxLength)
        {
            int maxIndex = offset + maxLength;

            for (int i = offset; i < maxIndex; i++)
            {
                // Skip non-nulls.
                if (buffer[i] != 0) continue;
                // First null we find, return the string.
                return Encoding.ASCII.GetString(buffer, offset, i - offset);
            }
            // Terminating null not found. Convert the entire section from offset to maxLength.
            return Encoding.ASCII.GetString(buffer, offset, maxLength);
        }

        private static string Cp1251BytesToString(byte[] buffer, int offset, int maxLength)
        {
            int maxIndex = offset + maxLength;

            for (int i = offset; i < maxIndex; i++)
            {
                // Skip non-nulls.
                if (buffer[i] != 0) continue;
                // First null we find, return the string.
                //               return Encoding.ASCII.GetString(buffer, offset, i - offset);
                return Encoding.GetEncoding(1251).GetString(buffer, offset, i - offset);
            }
            // Terminating null not found. Convert the entire section from offset to maxLength.
            return Encoding.GetEncoding(1251).GetString(buffer, offset, maxLength);
        }

        private GrdE Disconnect()
        {
            GrdE retCode; // Error code for all Guardant API functions
            string logStr = "";
            // -----------------------------------------------------------------
            // Close hGrd handle. Log out from dongle/server & free allocated memory
            // -----------------------------------------------------------------
            logStr = "Closing handle: ";
            retCode = GrdApi.GrdCloseHandle(_grdHandle);
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            // -----------------------------------------------------------------
            // Deinitialize this copy of GrdAPI. 
            // GrdCleanup() must be called after last GrdAPI call before program termination
            // -----------------------------------------------------------------
            logStr = "Deinitializing this copy of GrdAPI : ";
            retCode = GrdApi.GrdCleanup();
            logStr += GrdApi.PrintResult((int) retCode);
            logIt(logStr);
            ErrorHandling(_grdHandle, retCode);

            //Console.ReadLine();

            return GrdE.OK;
        }

        //----------------------------------------------------------------------------------------------
        //  Handle errors
        //  Prints operation result, closes handle and forces program termination on error  
        //  Input:  Handle to Guardant protected Container
        //	Input:  error code
        //	return: error code
        //----------------------------------------------------------------------------------------------
        private static GrdE ErrorHandling(Handle hGrd, GrdE nRet)
        {
            // print the result of last executed function
            //logIt(GrdApi.PrintResult((int)nRet));
            string logStr = "";

            if (nRet != GrdE.OK)
            {
                if (hGrd.Address != 0) // Perform some cleanup operations if hGrd handle exists
                {
                    // Close hGrd handle, log out from dongle/server, free allocated memory
                    logStr = ("Closing handle: ");
                    nRet = GrdApi.GrdCloseHandle(hGrd);
                    logStr += GrdApi.PrintResult((int) nRet);
                    logIt(logStr);
                }

                // Deinitialize this copy of GrdAPI. GrdCleanup() must be called after last GrdAPI call before program termination
                logStr = "Deinitializing this copy of GrdAPI : ";
                nRet = GrdApi.GrdCleanup();
                logStr += GrdApi.PrintResult((int) nRet);
                logIt(logStr);

                // Terminate application
                //Environment.Exit((int)nRet);
            }
            return nRet;
        }
    }
}

#endif